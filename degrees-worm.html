
<!-- saved from url=(0028)https://aeium.github.io/729/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>729</title>

</head><body><div id="container">
<canvas id="gears" width="820" height="820" style="z-index: 30;"></canvas>

<script src="./game-template_files/sketch.min.js.download"></script>

<script>
//  <script><iframe scrolling="no" frameborder="0" allowtransparency="true" src="./game-template_files/widget_iframe.5b0c4d3ea3997aa2c22eac39be510646.html" title="Twitter settings iframe" style="display: none;"></iframe></body></html>

// https://gist.github.com/joates/6584908
function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

var toothSize = 20

var recordFrames = false
if(recordFrames){

var ws = new WebSocket('ws://localhost:8080/');
		ws.onopen = function() {
			console.log('CONNECT');
		};
		ws.onclose = function() {
			console.log('DISCONNECT');
		};
		ws.onmessage = function(event) {
			console.log('MESSAGE: ' + event.data);
		};
		
		var frames = 656100;
		// Request Animation Frame Override
		var raf = window.requestAnimationFrame;
		var next = null;
		var hold = false;
		window.requestAnimationFrame = function rafOverride(callback) {
		  // Find canvas
		  var canvas = document.getElementById("gears");//document.querySelector('canvas');
		  if (canvas) {
		    // Done capturing?
		    if (frames < 0) {
		      window.requestAnimationFrame = raf;
		      return raf(callback);
		    }
		    // Hold rendering until screenshot is done
		    if (!hold) {
		      hold = true;
		      frames--;
		      setTimeout(function () {
		        callback();
		        capture(canvas, function () {
		          // Resume rendering
		          hold = false;
		          rafOverride(next);
		        });
		      }, 5);
		    }
		    else {
		      next = callback;
		    }
		  }
		  else {
		    // Canvas not created yet?
		    return raf(callback);
		  }
		}
		function capture(canvas, callback) {
		  // Capture image and strip header from string.  
		  
		  //var pixNum = animRetY * 810 +  animRetX
		  
		  //console.log(pixNum)
		  
		  
		  var image = canvas.toDataURL('image/png').slice(22); //("000000" + pixNum).slice(-6) + 
		  // Writing image as msg
		  ws.send(image);
		  setTimeout(function () {
		    // Resume rendering
		    callback();
		  }, 5);
		}

}

// d = 2 * pi * r   d/(2*pi) = r 

var canvas = document.getElementById('gears')
var ctx    = canvas.getContext('2d')


ctx.fillStyle   = 'grey'
ctx.strokeStyle = 'black'
ctx.lineWidth   = 3

// data oriented makes more sense, but for this task and also in general
metaList     = []
xPositions   = []
yPositions   = []
teethNums    = []
angles       = []
parities     = []

attachments      = []   // this is going to be a list of lists
attachmentAngles = []
meshAngles       = [] // angle of where mesh starts


wormHead         = [0, 0.0 ]    // int gear index, float radian position
  
wormStarts       = []
wormStops        = []


function intersectTwoCircles(x1,y1,r1, x2,y2,r2) {
  var centerdx = x1 - x2;
  var centerdy = y1 - y2;
  var R = Math.sqrt(centerdx * centerdx + centerdy * centerdy);
  if (!(Math.abs(r1 - r2) <= R && R <= r1 + r2)) { // no intersection
    return []; // empty list of results
  }
  // intersection(s) should exist

  var R2 = R*R;
  var R4 = R2*R2;
  var a = (r1*r1 - r2*r2) / (2 * R2);
  var r2r2 = (r1*r1 - r2*r2);
  var c = Math.sqrt(2 * (r1*r1 + r2*r2) / R2 - (r2r2 * r2r2) / R4 - 1);

  var fx = (x1+x2) / 2 + a * (x2 - x1);
  var gx = c * (y2 - y1) / 2;
  var ix1 = fx + gx;
  var ix2 = fx - gx;

  var fy = (y1+y2) / 2 + a * (y2 - y1);
  var gy = c * (x1 - x2) / 2;
  var iy1 = fy + gy;
  var iy2 = fy - gy;

  // note if gy == 0 and gx == 0 then the circles are tangent and there is only one solution
  // but that one solution will just be duplicated as the code is currently written
  return [[ix1, iy1], [ix2, iy2]];
}



// the basic idea is to have a set of gears that are intermeshed, but some of the gears have gaps.
// the player must move the gears back and forth to detangle the original gear

function drawGears(){

    //ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'skyblue'
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    //for(var i = 0; i < xPositions.length; i++){
    //    lasers(i)
    //}
    
    for(var i = 0; i < xPositions.length; i++){
        drawGear(i)
    }
    
    var wHG  = wormHead[0]  // worm head gear
    var wHA  = wormHead[1]  // worm head angle
    
    //console.log(wormHead)
    
    var radius = (teethNums[wHG]* 2 * toothSize)/(2 * Math.PI)
    
    var ret = moveTowards(xPositions[wHG],yPositions[wHG],wHA,radius)

    //console.log(ret)
    
    ctx.strokeStyle = 'yellow'
    ctx.fillStyle = 'yellow'
    
    ctx.beginPath()
    
    ctx.arc(ret[0], ret[1], 15, 0,  2*Math.PI)
    
    ctx.fill()
    ctx.stroke()
    ctx.closePath()
   
}

function drawGear(index){ 

    var x      = xPositions[index]
    var y      = yPositions[index]
    var teeth  = teethNums[index]
    var angle  = angles[index]    // angle is in radians, 0/2 will be 6:00, 1 will be 12:00
    var parity = parities[index]
    
    
    
    var teethSegments = teeth * 2
    
    var radius = (teethSegments * toothSize)/(2 * Math.PI)
    
    //console.log(angle)
    
    var arcFraction = 2*Math.PI / teethSegments
    
    ctx.beginPath()
    
    
     
    for(var i = 0; i < teethSegments+1; i++){

        //console.log(i)

        if(i%2 == parity){
            ctx.arc(x,y,radius-10,(angle-arcFraction/2)+i*arcFraction+arcFraction/6,(angle-arcFraction/2)+(i+1)*arcFraction-arcFraction/6)
        } else {
            ctx.arc(x,y,radius+10,(angle-arcFraction/2)+i*arcFraction+arcFraction/6,(angle-arcFraction/2)+(i+1)*arcFraction-arcFraction/6)
        }
    }
    
    if(parity == 0){
    
        ctx.fillStyle = 	"rgb(42,42,52)"
    
    } else {
    
        ctx.fillStyle = 	"rgb(100,100,110)"
    }
    
    ctx.fill()
    //ctx.stroke()
    ctx.closePath()
    
    /*
    
    ctx.strokeStyle = 'green'
    ctx.lineWidth = 6
    
    for(var i = 0; i < wormStarts[index].length; i += 1){
    
        var start = wormStarts[index][i]
        var end = wormStops[index][i]
    
        console.log('~~~~~')
        console.log(start)
        console.log(end)
    
        ctx.beginPath()
        ctx.arc(x,y,radius,start,end)
        ctx.stroke()
        ctx.closePath()
        
    
    }*/
    
    
    ctx.font = "20px Georgia";
    ctx.fillStyle = 'red'
    
    ctx.fillText(index, x,y)
    
    ctx.strokeStyle = 'red'
    
    for(var i = 0; i < meshAngles[index].length; i += 1){
    
        //var targetX = xPositions[attachments[index][i]]
        //var targetY = yPositions[attachments[index][i]]
        
        var meshA = meshAngles[index][i]
        
        var ret1 = moveTowards(x,y,meshA[0], radius) 
        var ret2 = moveTowards(x,y,meshA[1], radius) 
        
        ctx.beginPath()
        
        var drawX1 = x//ret1[0] * .9  //x * .6 + targetX * .4
        var drawY1 = y//ret1[1] * .9 //y * .6 + targetY * .4
        
        ctx.moveTo(drawX1,drawY1)
        
        var drawX2 = ret1[0] * 1 //x * .6 + targetX * .4
        var drawY2 = ret1[1] * 1 //y * .6 + targetY * .4
        
        ctx.lineTo(drawX2, drawY2)
        
        ctx.stroke()
        ctx.closePath()
        
        ctx.beginPath()
        
        var drawX1 = x//ret2[0] * .9 //x * .6 + targetX * .4
        var drawY1 = y//ret2[1] * .9 //y * .6 + targetY * .4
        
        ctx.moveTo(drawX1,drawY1)
        
        var drawX2 = ret2[0] * 1 //x * .6 + targetX * .4
        var drawY2 = ret2[1] * 1 //y * .6 + targetY * .4
        
        ctx.lineTo(drawX2, drawY2)
        
        ctx.stroke()
        ctx.closePath()
    
    }
    
    
}

function scanLinks(){

    for(var i = 0; i < metaList.length; i++){
    
        var xPos = xPositions[i]
        var yPos = yPositions[i]
        
        for(var j = 0; j < metaList.length; j++){
        
            if(j != i){

                var compX = xPositions[j]
                var compY = yPositions[j]

                var distance1 = (teethNums[i] * toothSize)/(2 * Math.PI) + (teethNums[j] * toothSize)/(2 * Math.PI)

                var distance2 = Math.sqrt(Math.pow((xPos - compX),2) + Math.pow((yPos - compY),2)) /2
                
                var diff = distance2 - distance1
                
                if(i == 12){
                
                    //console.log('gear ' + i + ' and ' + j + ' distance: ' + diff)
                    console.log('distance1 to ' + j + ' : ' + distance1)
                    console.log('distance2 to ' + j + ' : ' + distance2)
                    console.log('diff         ' + j + ' : ' + diff)
                
                }
                
                if(diff < 0){
                
                    // invalid mesh
                    
                    console.log('invalid mesh detected between gear ' + i + " and " + j )
                
                }
                else if(diff < 10){
                
                    // valid mesh
                    
                    if(! attachments[i].includes(j)){
                    
                        attachments[i].push(j)
                    
                    }
                    
                    if(! attachments[j].includes(i)){
                    
                        attachments[j].push(i)
                    
                    }
                
                }
                else{
                
                    // too far
                    
                    // do nothing for now
                
                }
                
            }            
        
        
        
        
        
        }
    
    }
    
    for(var i = 0; i < metaList.length; i++){
    
        var xPos = xPositions[i]
        var yPos = yPositions[i]
        
        for(var j = 0; j < attachments[i].length; j++){
        
            //if(j != i){
        
            var targetX = xPositions[attachments[i][j]]
            var targetY = yPositions[attachments[i][j]]
            
            var r1 = (teethNums[i]*2 * toothSize)/(2 * Math.PI) +5
            var r2 = (teethNums[j]*2 * toothSize)/(2 * Math.PI) +5
            
            var ret = intersectTwoCircles(xPos,yPos,r1,targetX,targetY,r2)
    
            attachmentAngles[i].push(getAngle(xPos,yPos,targetX,targetY))  // push to most recent one

            var angletoMesh11 = getAngle(xPos,yPos,ret[0][0],ret[0][1])
            var angletoMesh12 = getAngle(xPos,yPos,ret[1][0],ret[1][1])

            meshAngles[i].push([angletoMesh11,angletoMesh12])
            //meshAngles[index2].push([angletoMesh21,angletoMesh22])

            //}
        }
    }
    
}

Number.prototype.between = function(a, b) {
  var min = Math.min.apply(Math, [a, b]),
    max = Math.max.apply(Math, [a, b]);
  return this > min && this < max;
};

function jump(){

    var angle = wormHead[1] % (Math.PI * 2)

    console.log(attachments[wormHead[0]])
    console.log(angle)
    console.log(wormHead[1])
    

    var meshA = meshAngles[wormHead[0]]

    
    if(angle.between(meshA[0][0],meshA[0][1])){
        console.log(attachments[wormHead[0]][0])
    }
    if(angle.between(meshA[1][0],meshA[1][1])){
        console.log(attachments[wormHead[0]][1])
    }
    if(angle.between(meshA[2][0],meshA[2][1])){
        console.log(attachments[wormHead[0]][2])
    }


}

function lasers(index){

    var x      = xPositions[index]
    var y      = yPositions[index]
    var teeth  = teethNums[index]
    var angle  = angles[index]    // angle is in radians, 0/2 will be 6:00, 1 will be 12:00
    var parity = parities[index]
    
    
    
    var teethSegments = teeth * 2
    
    var radius = (teethSegments * toothSize)/(2 * Math.PI)
    
    //console.log(angle)
    
    var arcFraction = 2*Math.PI / teethSegments
    
    ctx.beginPath()

    ctx.beginPath()
    ctx.moveTo(x,y)
    
    var dest = moveTowards(x,y, angle, 2000 )
    
    if(parity == 1){
        ctx.strokeStyle = "rgb(100,100,110)"
    } else {
        ctx.strokeStyle = "rgb(42,42,52)"
    }
    
    ctx.lineTo(dest[0],dest[1])
    ctx.stroke()
    ctx.closePath()
    
    ctx.strokeStyle = 'black'

}

// prev index gives reference to the previous gears
// toothSegmentAttach tell new gear where to go and what slot or peg to touch
// checkValid scans other gears to find conflicts (if I implement it)

function addGear(x,y,teeth,angle,parity = 0, attach = []){

    var selfIndex = metaList.length

    metaList.push(selfIndex)
    attachments.push(attach)
    xPositions.push(x)
    yPositions.push(y)
    teethNums.push(teeth)
    angles.push(angle)
    parities.push(parity)

    wormStarts.push([])
    wormStops.push([])
    
    attachmentAngles.push([])
    meshAngles.push([])
   
    
    
    return selfIndex
    
}


function moveTowards(x,y,angle,distance){

    newX = x + Math.cos(angle) * distance
    newY = y + Math.sin(angle) * distance
    return [newX,newY]
}

function getAngle(x1,y1,x2,y2){

    diffX = x2 - x1
    diffY = y2 - y1

    return(Math.atan2(diffY,diffX))// + Math.PI)
    
}


function rotate(startIndex, angleDiff, workList = metaList){

    // list contains a number for each gear.
    // I don't want to process any gear more than once on the same turn
    // So I am having each rotation cross it's gear number off the list
    
    if(workList.includes(startIndex)){
        var self = workList.indexOf(startIndex)
        workList = workList.slice(0, self).concat(workList.slice(self + 1, workList.length))
    }
    else {
        return workList
    }
    //var workList = list.slice(0, i).concat(list.slice(i + 1, list.length))

    //console.log(workList)
    
    var startGearTeeth = teethNums[startIndex]
    
    if(parities[startIndex] == 0){
        angles[startIndex] += angleDiff
    } else {
        angles[startIndex] -= angleDiff
    }
    
    if(startIndex == wormHead[0]){
    
        if(parities[startIndex] == 0){
            wormHead[1] += angleDiff
        } else {
            wormHead[1] -= angleDiff
        }
    
    }
    
    
    for(var i = 0; i < attachments[startIndex].length; i++){
    
        if(workList.includes(attachments[startIndex][i])){
        
            var target = attachments[startIndex][i]
            var targetTeeth = teethNums[target]
            
            var targetDiff = angleDiff * (startGearTeeth / targetTeeth)
            
            workList = rotate(attachments[startIndex][i],targetDiff,workList)
        }
    }

    return workList
    
}


function rotateRedraw(startIndex,angleDiff){

    ret = rotate(startIndex, angleDiff)
    
    drawGears()

}

function addPairedGear(prevIndex,toothSegmentAttach, teethNew, checkValid = false){

    var prI = prevIndex
    
    var prevX        = xPositions[prI]
    var prevY        = yPositions[prI]
    
    var prevAngle    = angles[prI]
    var prevSegments = teethNums[prI]*2
    
    var arcFractionOld = 2*Math.PI / prevSegments
    var towardsNew = prevAngle + toothSegmentAttach * arcFractionOld // gives the angle towards the new gear
    
    var oldRadius = (prevSegments * toothSize)/(2 * Math.PI)
    var newRadius = (teethNew * 2 * toothSize)/(2 * Math.PI)

    var newPos = moveTowards(prevX,prevY,towardsNew,oldRadius+newRadius+3)
    
    var newX = newPos[0]
    var newY = newPos[1]
    
    var oldParity = parities[prevIndex]
    
    //console.log(towardsNew)
    
    attachments[prevIndex].push(xPositions.length)  // old length of this will be index of new object
    addGear(newX,newY,teethNew,towardsNew+Math.PI,(oldParity+1)%2, attach = [prevIndex])

}

addGear(110,340,12,1)

addPairedGear(0,2,12)
addPairedGear(1,10,12)
addPairedGear(2,10,12)
addPairedGear(3,10,12)
addPairedGear(4,10,12)
addPairedGear(5,10,12)
addPairedGear(6,10,12)
addPairedGear(7,10,12)
addPairedGear(8,10,12)
addPairedGear(9,10,12)
addPairedGear(10,10,12)
//addPairedGear(11,10,12)

addPairedGear(0,20,7)
addPairedGear(1,4,7)
addPairedGear(2,4,7)
addPairedGear(3,4,7)
addPairedGear(4,4,7)
addPairedGear(5,4,7)
addPairedGear(6,4,7)
addPairedGear(7,4,7)
addPairedGear(8,4,7)
addPairedGear(9,4,7)
addPairedGear(10,4,7)
addPairedGear(11,4,7)

addPairedGear(12,8,4)
addPairedGear(13,8,4)
addPairedGear(14,8,4)
addPairedGear(15,8,4)
addPairedGear(16,8,4)
addPairedGear(17,8,4)
addPairedGear(18,8,4)
addPairedGear(19,8,4)
addPairedGear(20,8,4)
addPairedGear(21,8,4)
addPairedGear(22,8,4)
addPairedGear(23,8,4)
//addPairedGear(23,6,4)

scanLinks()

/*
wormStarts[0].push(1)
wormStarts[0].push(2)
wormStarts[1].push(1)
wormStarts[1].push(2)

wormStarts[2].push(1)
//wormStarts[2].push(2)

wormStops[0].push(1.5)
wormStops[0].push(2.5)
wormStops[1].push(1.5)
wormStops[1].push(2.5)

wormStops[2].push(5)
//wormStops[2].push(2.5)*/


//addGear(545,420,13,1)

worm = []


drawGears()

var rotSum = 0

var fps = 40
function movediv(timestamp){
    //setTimeout(function(){ //throttle requestAnimationFrame to 20fps
        rotateRedraw(0,.01)
        rotSum += .01
        
        total = (Math.PI * 2) / 12
        
        if(rotSum >= total){
        
            recordFrames = false
        }
        
        window.requestAnimationFrame(movediv)
    //}, 1000/fps)
}

var frameCount = 0 

function animate(){

        //console.log(rotSum)
    
        
        rotateRedraw(0,.01)
        rotSum += .01
        

        
        total = (Math.PI * 2) / 12
       
        if(false){ //rotSum >= total){
        
            recordFrames = false
        } else {
        
            if( frameCount % 10 == 0){
            
                //console.log("interval  " + rotSum + " / " + total)
            
            }
            
            //console.log(frameCount)
        
            window.requestAnimationFrame(animate)

        }
        frameCount += 1
}

 window.onload = function() {
    animate()
 };

document.onclick = function(){jump()};

</script>

